OP–XY Project File Format Breakdown
Project Files and Storage
Each OP–XY project is saved as a single binary file (with extension likely .xy) on the device’s 8 GB internal storage[1][2]. When you connect the OP–XY to a computer in MTP mode, the device mounts as a drive containing three top-level folders: presets, projects, and samples[3]. Under projects/, user-created project files appear alongside a special “backups” subfolder[4]. The backups folder holds the history of saved versions for all projects – each time you save (manually or via auto-save), a snapshot is stored there so you can roll back to earlier versions[5]. To fully back up a project, both the project’s main file and its corresponding backup entries should be copied[6]. Project names are user-defined and can be renamed on-device or from a computer; only alphanumeric characters plus -, #, or space are supported in names[7] (using unsupported symbols may require renaming).
Data not self-contained: Projects do not embed audio sample data. Any samples used by a project are referenced from the OP–XY’s samples directory rather than stored in the .xy file[8][9]. This means that when transferring or reverse engineering a project, you must also account for the external sample files it points to (and ensure those files remain in the correct location or accompany the project). The manual notes that if you move projects between devices, you must also copy the corresponding samples to avoid broken references[10]. Similarly, preset files (stored under the presets folder) can encapsulate sampler instruments; when a preset is loaded into a project, its configuration becomes part of the project data (though the actual sample files used by the preset still reside in the preset’s folder)[11]. In summary, the project file contains the arrangement and parameter data, while large media assets (samples) are external.
Each project file can be thought of as a container for all the musical data: sequences (patterns), instrument and track settings, scenes, songs (arrangements), and mix/effect settings. Below we break down each of these components and the data that must be saved for them in the file format.
Patterns and Sequencer Data
Pattern Basics: The OP–XY uses a pattern-based sequencer. Each track (both the 8 instrument tracks and 8 auxiliary tracks) can hold up to 9 patterns[12]. A pattern is essentially a sequence of musical steps (think of it like a loop on one track). Patterns are limited in length and note capacity: each pattern can contain a maximum of 120 notes[13]. This implies the file must record the note events for each pattern up to that limit. The sequencer supports polyphony on tracks (the device is 24-voice polyphonic overall[14]), so a single step can actually hold multiple simultaneous notes (chords) on instrument tracks. The file likely represents each pattern as a list of step events with attributes like pitch, velocity, and possibly gate length or tie information. (Notably, OP–XY doesn’t explicitly store note lengths in a traditional way; instead, the sequencer uses a “hold” component to extend notes, discussed below, and envelope release times for sustain.)
Step Resolution and Length: While not directly stated as a step count in the manual, the OP–XY is described as a 64-step sequencer in product materials (64 steps typically equals 4 bars of 16th notes in 4/4). The “120 notes per pattern” limit suggests patterns can be up to 4 bars long with dense chords, or potentially patterns can extend beyond 4 bars if fewer notes are used. In practice, patterns can be lengthened or multiplied using the bar function (for example, to make a 2-bar pattern play over 4 bars at half speed)[15], but regardless of how length is handled, the project file must encode the timing of each note event within the pattern. Likely each pattern has an implicit step grid (e.g. 16 steps per bar) and the file records which steps have notes. If micro-timing or swing offsets are applied, those might not be stored per step (swing is handled globally via groove settings, see Tempo and Groove below).
Polyphony in Patterns: A single step can contain multiple note triggers (polyphonic sequencing). The manual confirms that if you hold a step you can see “the note or notes recorded to that step”[16]. Thus, the pattern data structure must allow a list of pitches (and their velocities) for each step. The simplest representation is a step-by-step list where each step has zero, one, or several notes. Velocity values can either be per note or a single value if the step component forces them (see below). Given the mention of velocity step components and global groove accenting, it’s likely velocity is recorded per note normally, but can be overridden by certain effects.
Step Components (Per-Step Modifiers): One of the most important advanced features to account for is step components. These are special modifiers you can add to any step to alter its behavior. The OP–XY offers 14 different step components that can be combined arbitrarily on the same step[17]. These include things like: - Pulse: repeat the step’s note multiple times before moving on[18]. - Hold: sustain (extend) the step for a number of steps without advancing the sequencer[19]. - Multiply (Ratchet): subdivide a step into rapid retriggered sub-notes (e.g. ratcheting hi-hats)[20]. - Velocity: force the step’s velocity to a specific value[21]. - Ramp Up / Ramp Down: transpose the note up or down by an interval each time it repeats[22]. - Random: randomize the pitch of the step within a range on each hit (quantized to the current scale)[23]. - Portamento: add a glide into and out of the note with a specified amount[24]. - Bend: apply a pitch bend curve to the note (patterns selectable via values)[25]. - Tonality: transpose the step by a fixed interval (static shift)[26]. - Jump: upon playing this step, jump to a different step in the pattern (creating a loop or skip)[27]. - Skip (Parameter Lock and Step Component): conditional triggers – these let you specify that a parameter lock or an entire step should only fire on every Nth repetition of the pattern[28]. For example, “skip parameter lock” means the step’s recorded parameter automation will only apply every few loops, and “skip trigger” means the note plays only once every N cycles[28].
Because multiple step components can stack on one step[29], the file format needs a way to encode a set of flags or sub-structures per step. For each component present, its type and value (often an integer or setting chosen via keyboard) must be stored. For example, if a step has a Pulse component with value 3 (repeat thrice) and a Random component with range ±2 semitones, both of those must be encoded for that step. This is more complex than a simple on/off trigger and greatly expands what data is associated with a single step.
Parameter Locks: Although the manual doesn’t explicitly use the term “parameter locks” in the OP–1/OP–Z sense, it implicitly supports per-step automation. For instance, the Skip Parameter Lock component’s description – “allows you to play a parameter lock on a step every defined number of repetitions”[28] – confirms that steps can have parameter automation recorded (with the ability to conditionally apply it). Therefore, the pattern data likely includes any knob values (synth parameters, effect sends, etc.) that were locked to that step. The file must record which parameter was changed and its value for that step. In essence, each step can contain: note events (pitches/velocities), a set of active step components (with values), and optionally a set of parameter-value locks. This structured event data is crucial for reconstructing the sequencer timeline.
Pattern Linking and Sound Presets: Normally, each pattern on a track can have its own instrument sound or preset. By default, switching patterns does change the sound to whatever was saved with that pattern, but the OP–XY offers a “sound link” feature to override this[30]. When sound link is enabled on a track, all patterns on that track use a single shared sound (the current preset) rather than loading each pattern’s saved preset[30]. For the file format, this means that by default each pattern likely stores a reference to the instrument settings used (so that Pattern 1 might be a bass synth patch, Pattern 2 a pad patch, etc.), but there may be a flag for “sound-linked” patterns where the instrument isn’t reloaded. It’s possible that internally, sound link simply causes the project to ignore the per-pattern instrument data and keep using one track-level instrument setting. In any case, when sound link is off (the normal mode), the project must remember the instrument engine and patch parameters for each pattern so that pattern changes restore the correct sound[30]. Conversely, if sound link is on, the current track’s instrument settings might be stored only once and applied to all that track’s patterns in memory (the exact implementation might be to duplicate the data or to have a pointer – but from a reverse-engineering perspective, be aware that pattern and sound data can be decoupled).
Finally, pattern indexing is per track. Each track has Pattern 1–9 independently; for example, Scene arrangements (next section) will call for “Track 2, Pattern 3” etc., not a single global pattern number. The file likely enumerates patterns track-by-track. The manual confirms this with editing actions: you can copy a pattern (including its engine and all parameters) from one track to another, or clear a pattern slot on a track[31][32]. So, structurally, we expect something like an array of 16 tracks, each containing up to 9 pattern structures.
Scenes and Mix Snapshots
A Scene in OP–XY is a global snapshot of pattern assignments (one pattern per track) and certain mix settings. In other words, a scene defines “which pattern is playing on each track at this moment” and also how the mixer is set at that time. The device provides up to 99 scenes per project[33]. In the file, scenes likely are stored as an indexed list (1 through 99) with each scene containing: - The pattern number (1–9) selected for each of the 16 tracks[33]. - The track volume and mute state for each track in that scene[34]. The manual states explicitly that each scene remembers the pattern arrangement “as well as the track volumes and mutes.”[34] This means if you’ve muted the drums or lowered the bass in a particular section, that is saved in the scene. When switching scenes during playback, those track levels and mutes jump to the stored values.
It is very likely that pan and effect send levels are also part of the “mix settings” stored per scene, though the documentation only calls out volumes and mutes clearly. The wording “mix settings” is used elsewhere to encompass levels, pans, and sends[35][36]. It’s reasonable to infer that a scene could capture full mix snapshots (volume, pan, FX send for each track) to allow different mix tweaks in different song sections. However, because the manual highlights volume and mute specifically[34], it’s safe to confirm at least those are stored. In any event, a scene structure in the file should allocate space for each track’s pattern ID and mix parameters (volume, mute, and possibly pan, send1, send2). This effectively links the sequencing data (patterns) with the musical “mix” state.
Scenes are the building blocks for songs (arrangements). When you change to a scene on the OP–XY, all tracks jump to the patterns defined by that scene, and track mixers adjust accordingly. Note that a scene’s length is defined by its longest track pattern[33]. If one track’s pattern is 4 bars and others are 2 bars, the scene will play for 4 bars (the shorter patterns presumably loop or hold). This implies no additional timing info needs to be stored in the scene beyond the pattern choices; the device can compute scene duration from the patterns’ content. But it’s an important detail for how scenes chain in a song.
From a data standpoint, storing 99 scenes with 16 tracks each (and multiple parameters per track) is quite a bit of data, but certainly feasible. Likely each scene entry in the file is a fixed-size record.
The OP–XY UI allows creating, copying, pasting, and resetting scenes[37][38], which suggests scenes are enumerated and editable freely. An empty scene can be created by selecting a new scene number, at which point the device copies the current scene’s content as a starting point[39]. This indicates that scene slots are always defined in terms of differences from others only at creation time; ultimately, each scene stored will fully specify patterns and mix regardless of how it was created (so no delta or relative encoding in the file – each scene stands alone).
Songs (Timeline Arrangements)
A Song on the OP–XY is a sequence of scenes played in order, allowing you to build a full track/arrangement from the smaller sections. The OP–XY can hold up to 14 songs per project (one for each white keyboard key, since songs are selected with the 14 white keys)[40]. Each song, in turn, can sequence up to 96 scene changes in its timeline[41][42].
In practice, a song is like a playlist of scene numbers. The file will need to store, for each song: - The ordered list of scene indices that comprise that song, up to 96 entries (fewer if the song is shorter)[42]. The scenes are referenced by their numbers (1–99). - Likely the length of the song (number of steps in that sequence used). - A flag for whether the song is set to loop or stop at the end. There is a Loop Song toggle accessible in song mode, which when enabled will cause the song to jump back to the first scene after the last scene finishes[43]. So the song data should include a boolean for “loop enabled”[43]. - Possibly the current position or next scene to cue, though that wouldn’t be persistent (more a runtime state). Only the fixed sequence and settings need storing.
The user can insert or remove scenes in the middle of a song order[44], which implies the file likely stores songs as a simple array of scene numbers that can be edited. Deleting a scene from the song doesn’t delete the scene itself, it just removes it from that song’s play order[45]. Each song can also be copied or pasted in its entirety[46], meaning each song is an independent entity (the file probably has 14 song slots that can be manipulated).
Additionally, since multiple songs exist per project, the file might have an index or naming for songs. The UI selects songs by number (1–14 via the piano keys)[40] and doesn’t suggest custom names for songs, so referencing by index is sufficient. There is no indication of separate tempos per song – all songs in a project share the project’s global tempo (see Tempo below). If different songs needed different tempos, one would likely use separate projects.
In summary, song data in the file includes: an ordered list of scene references for each of up to 14 songs, plus at least a loop flag per song. The maximum length is 96 scene slots per song, but this exact limit can be stored as a constant or an end-of-sequence marker. The format should allow fewer than 96 entries if the song is shorter. (If needed, unused entries might be zero or a null scene indicator; since scene 0 isn’t used, 0 could mark the end.)
Instrument Tracks (1–8) – Engines and Parameters
The OP–XY has 8 dedicated instrument tracks (tracks 1–8). Each instrument track can be loaded with either a built-in synth engine or one of the sampler engines (drum sampler, one-shot sampler, multi-sampler)[47]. The file must capture all the settings related to the instrument on each track (and, as discussed, possibly per pattern if different patterns use different engines/presets).
Engine type and preset: For a given track/pattern, the first thing to save is which sound engine is in use. Teenage Engineering provides a number of synth engines – e.g., “Axis”, “Dissolve”, “Epiano”, “Organ”, “Wavetable”, etc., as well as an “External” engine for MIDI output[48]. The sampler engines are treated similarly as track engines (the manual calls them “samplers” but selection is done in the same way as synth engines)[47][49]. So, engine identification (a numeric ID or code) is a necessary part of the track data. If the engine is a synth, all its internal parameters must be stored; if it’s a sampler, then sample assignments and related parameters (see next section) are stored.
The OP–XY allows saving and loading presets, which are essentially saved instrument patches. A preset encompasses the engine selection and all its parameter settings (and references to samples if it’s a sampler)[50][51]. When you load a preset into a track, the project will reflect those parameters. Conversely, when a track’s sound is tweaked from scratch, it can be saved as a preset for reuse. From the file perspective, however, there is no need to reference the preset name or file – the project file will contain the resulting engine type and parameter values (the preset is just an external shortcut to set those). The manual indeed suggests that once a preset is loaded into a project, it’s just part of the project’s instrument config[52]. Therefore, each track’s instrument data in the project is self-contained (aside from sample file references). There’s no pointer to an external preset file; the preset’s effect was to populate these values.
Synth Engine Parameters: Each synth engine has a specific set of primary parameters controlled by the four encoders in Engine (M1) page[53]. Typically, Teenage Engineering synth engines have four main knobs (for example, OP-1’s engines had A, B, C, D parameters). OP–XY likely follows this, with each engine defining what Dark Grey, Mid Grey, Light Grey, and White encoders do when on the engine page[53]. The manual references an “engine chapter” for a full list of parameters per engine[53] – while those details aren’t all listed in the user guide text we have, reverse engineering the file will involve identifying how each engine’s parameters are stored. It’s safe to assume each engine’s unique parameters are saved (probably as 4 values, possibly more if an engine has hidden settings).
In addition to the engine-specific parameters, instrument tracks have standard synthesizer settings: - Amplitude Envelope: ADSR for volume. OP–XY provides two envelopes per track – one amplitude envelope and one filter envelope[54]. On the Envelopes (M2) page, the four encoders adjust Attack, Decay, Sustain, Release for whichever envelope is selected[55]. Thus, for the amplitude envelope, four values must be stored. There is also a toggle to switch the view between amp envelope and filter envelope[56], but likely both sets of ADSR are stored regardless of the UI state. - Filter Envelope: Another set of ADSR values controlling the filter modulation. That’s another four values (Attack/Decay/Sustain/Release for the filter envelope). - Play Mode: Each track can be Polyphonic, Monophonic, or Legato mode. This is set by holding shift in the envelope page and using the dark gray encoder to choose Poly/Mono/Legato[57]. So a mode flag per track (poly=0, mono=1, legato=2, for example) is stored. - Portamento Time: The glide time between notes in mono/legato mode, adjusted by the mid grey encoder[58]. A numeric value for portamento is stored per track. - Pitch Bend Range: The range of the pitchbend controller in semitones, set by the light grey encoder[59]. Store an integer (e.g. 2, 12, etc). - Preset Volume: A secondary volume control per instrument (distinct from the main track mixer level)[60]. This ensures different patches have consistent loudness. The preset volume value is stored with the instrument settings (White encoder in envelope page)[60]. - Filter Settings: On the Filter (M3) page, OP–XY offers multiple filter types and their parameters. The filter type (algorithm) itself can be changed (by shift+M3) – the device has “several filters, each with their own character”[61]. So the filter type ID is stored. Then, for the filter currently selected, the following are stored: Cutoff frequency (Dark encoder)[62], Resonance (Mid encoder)[63], Envelope Amount (Light encoder – how much the filter envelope modulates the cutoff)[64], and Key Tracking (White encoder – how much the filter opens/closes based on note pitch)[65]. These four values, plus filter type, constitute the filter settings for the track. - Additional Filter Send: Interestingly, the filter page in the manual hints at a “track send” or “aux out” send accessible via shift in filter page[66]. This appears related to routing the track to the secondary outputs (see External Audio Track below). Specifically, “aux out” on dark gray knob with shift[67] likely means how much of this track’s signal goes to the auxiliary output bus. If that is the case, the track’s audio routing to the multi-out (when it’s set to audio) is stored per track. We will cover this under external audio routing, but note that it might be saved as part of track settings or as part of the ext-audio track’s routing matrix. Either way, the concept is that each track can have an Aux Out send level separate from the main mix[68]. That needs to be accounted for in the project data (especially if you plan to reconstruct routing).
Track LFO: Each instrument track has an assignable low-frequency oscillator for modulations (this is LFO (M4) page)[69]. OP–XY offers 4 LFO types: Element, Random, Tremolo, and Value[70]. The LFO settings to store include:
LFO Type (which of the 4)[70].
LFO Rate/Source value – for standard LFOs this is the speed (Hz or synced divisions)[71]. For special types like Element or Random, this might select different behaviors (the manual notes the dark knob “adjusts the source or rate” and clicking it changes shape for some LFOs)[72]. For example, Element LFO’s source can be Gyro, Mic, Envelope, Sum[73], whereas Random LFO’s dark knob can be tempo-synced vs free rate[74]. So the stored data might be an LFO rate value and possibly a sub-setting (like a flag for tempo sync or a source selection).
LFO Amount (depth of modulation)[75].
LFO Destination Module – which module on the track is being modulated[76]. “Destination” could be engine, envelope, filter, etc., essentially selecting the target page or component.
LFO Destination Parameter – the specific parameter (encoder) within that module to modulate[77]. For instance, you might target the filter cutoff or the envelope decay, etc. In the UI, you choose destination and parameter with the light and white encoders respectively[78][77]. The combination identifies exactly what is controlled.
LFO Sub-parameters: Some LFO types have extra settings accessible by shift or encoder clicks[79]. For example, the Duck (sidechain) function is a special mod that uses audio or metronome as source to modulate volume – it has its own parameters (source track, amount, hold, release)[80][81][82]. The Element LFO has a source selection (Gyro/Mic/Envelope/Sum)[73]. Random LFO has an “envelope” (slew) setting accessible via shift on mid knob[83]. If any of these LFO types are in use, their specific parameters (e.g. Duck source and timing, or Element source type, etc.) must be saved in addition to the main four values above. The file format might allocate a fixed-size block for LFO settings that covers all possibilities (some fields unused for certain types).
In short, each instrument track’s state includes engine ID, engine parameter values, envelope settings (8 ADSR values), play mode, portamento, bend range, preset volume, filter type and 4 filter params, possibly aux send, and LFO (with multiple subfields). All of that is per track per pattern (if patterns carry their own instrument) or per track globally if linked. That’s a lot of parameters, but it’s comparable to what modern grooveboxes store per track.
MIDI Output Tracks: One special case of instrument engine is the “External” engine[84]. If an instrument track is set to engine “External”, it doesn’t produce sound internally; instead that track sends MIDI out (via USB or the TRS MIDI jack). When external engine is selected, the track effectively becomes a MIDI sequencer lane for an outboard synth. The project file still needs to store the fact that the engine is External (so no synth parameters, but we might consider if anything else is stored). In Project Settings, under the MIDI page, you assign a MIDI channel to each track[85]. So the MIDI channel number for this track’s output will be stored there (see Project Settings). Additionally, on the OP–XY, in External MIDI track mode (which is actually the auxiliary track 3, not an instrument track – more on that later), you can map 8 MIDI CC controls to the encoders[86]. However, for an instrument track using the External engine, it’s not clear if it uses the same interface or if it’s simply note and velocity out. The manual suggests using instrument tracks with External engine for controlling multiple MIDI devices (each track gets its own channel)[87][88]. It likely does not store CC mapping per instrument track (the CC mapping UI is specifically on the dedicated ext MIDI track). So for External engine tracks, the main things to store are the engine type = External and (in project settings) the MIDI channel. Note sequences on that track will be saved as normal patterns (notes, etc., which then get output as MIDI).
Voices Allocation: The OP–XY has a total of 24 voices of polyphony (for internal synth/sampler usage)[14]. By default, voices are allocated dynamically, but the project offers a setting to assign a certain number of voices to specific tracks (to prioritize them)[14]. In the Voices project settings page, you can set how many voices each track gets (e.g., ensure your pad track always can use 6 voices, etc.)[89]. This would be stored as part of project metadata – likely an array of 16 values (for 16 tracks) indicating reserved voice count or priority for each. This doesn’t affect the musical content, but it’s a configuration that the file retains to reproduce the same voice allocation on load. (If not set manually, all tracks share voices dynamically; possibly the default is zero or auto for each track.)
Sampler Tracks and Sample References
If an instrument track is set to a sampler engine (OP–XY has three: one-shot synth sampler, drum sampler, and multi-sampler[90][91]), then the project file must include detailed information about sample assignments and sample-specific parameters. These are among the most complex data structures, since they involve references to external sample files and per-key settings.
General Sample Handling: All samples reside in the device’s samples/ directory (8 GB storage). Recorded samples are automatically saved to samples/user/ (or subfolders within it) when you sample with the microphone or line in[92]. The OP–XY supports WAV and AIFF files[93]. Importantly, the file format likely references samples by a path or name. Possibly each sample is identified by a filename (and perhaps a subfolder path). The user manual warns to use simple filenames (allowed characters same as projects)[94], implying the project might store the literal filename and perhaps a folder reference (like which category folder). There is no evidence of a centralized sample index or hash; it’s probably just file paths or a relative path from samples/. For reverse engineering, expect to extract text strings for sample names within the project file.
One-shot Synth Sampler (Single Sample Instrument): This mode records or loads one sample and maps it across the keyboard for melodic play. When you record a sample in one-shot mode, the key you press is used as the root note tuning for that sample[95]. The sample can loop or play once. The parameters available (on the one-shot sample’s edit page) include: - Start, End points of the sample, and Loop Start, Loop End if looping (controlling which segment of the waveform plays)[96][97]. - Playback Direction (forwards or backwards)[98]. - Tune (pitch adjustment, likely in cents or semitones)[99]. - Loop Crossfade amount (to smooth loop transitions)[100]. - Sample Gain (level adjustment for the sample)[101]. - Loop Mode – although not explicitly labeled in the one-shot section, the multi-sampler section mentions loop modes like “loop forever vs until release vs off”[102] which likely apply to one-shots as well. Possibly one-shot sampler defaults to no loop unless you set loop points, but we should be prepared to store a loop enable flag or mode.
All these values must be stored for a one-shot sampler track’s instrument. Additionally, the root key (the original key that the sample is tuned to) should be stored. The manual says “the key you select will be the note that the sampler tunes the sample to” when recording[95], and presumably if you load a sample via the browser, it might assume C3 or allow setting root. There might be a parameter for root note or it may infer from file metadata (less likely). For completeness, consider that the project might store the root note for pitch calculations.
In the file, the one-shot sampler data would include: a reference to the sample file, and all the above parameters. Essentially it’s one “zone” covering the entire keyboard.
Drum Sampler (24-key Drum Kit): The drum sampler engine allows up to 24 different samples mapped to 24 keys (the OP–XY keyboard likely has 2 octaves available at a time, and it seems they use two octaves for drum kits)[103]. Typically these might be mapped to, say, chromatic keys from a certain range (perhaps C to B over 2 octaves, giving 24 slots). The project must store, for each of these possible 24 drum sample slots: - Whether a sample is assigned to that slot, and if so, the sample file name/path[92]. When you record into a key or load a sample onto it, it’s saved to user samples folder and assigned. Clearing a sample from a key “will only remove the assignment, not delete the sample file”[8] – confirming that the project just links to the file. - Tuning for that sample (each key can be tuned independently)[104]. - Start and End points for the sample playback on that key[105][106]. - Play Mode for that sample: options include Key (play while key held), One-shot (play entire sample on trigger), Mute Group (a choke group where samples cut each other off), or Loop (loop continuously)[107]. The project likely stores an enum or bitfield for the play mode per sample. - Playback Direction (forward/backward) per sample[108]. - Pan position for that sample (stereo panning)[109]. - Fade (Envelope) / Loop crossfade amount for that sample[110] (this likely applies to how clicks at the end are smoothed – possibly a small fade-out). - Gain level for that sample (relative volume)[111]. - Additionally, drum sampler editing has copy/paste and multi-select operations for convenience[112][113], but those don’t introduce new stored parameters – they just alter the above fields in bulk. - Sample Slicing: The drum sampler also includes a slicer tool, where you can take one sample and automatically slice it into multiple keys (transient slicing, etc.)[114][115]. If a user does this, effectively multiple keys will be filled with pieces of the same original sample. The file will then have those keys assigned to the same sample file, each with unique start/end settings. It also notes that slices are “assigned to choke each other”[115] – meaning if slice playback uses the Mute Group mode by default. So, one might see that all those keys get play mode = mute group and share an ID so that only one slice plays at a time. The project might not explicitly store the grouping beyond each having “mute group” mode (possibly all mute-group samples choke each other globally, or maybe a group ID – not specified, but likely any two set to Mute Group will choke each other).
Therefore, the drum kit data structure in the file will be something like an array of 24 slots, each with: sample reference (or null if empty), tune, start, end, playmode, direction, pan, fade, gain. It also needs to store how many slots are actually used or simply mark unused ones as such.
Multi-sampler (Multi-zoned Instrument): The multi-sampler is for mapping multiple samples across different key ranges (and velocities, though velocity layers aren’t explicitly mentioned, it might just be key zones). It supports up to 24 zones[116], which is enough to sample, say, a piano with 2–3 samples per octave across a few octaves. The UI workflow is: you pick different keys (from low to high) to sample, and the OP–XY automatically maps each sample to a zone from that key down to the previous sample’s key[117][118]. Specifically, “as you select keys from left to right OP–XY will automatically create zones... it fills the gaps by pitching those samples down”[118]. This implies: - Zones are ordered by base key. Each zone has a root key (the key you sampled it on) and likely spans from that root downwards until the next lower zone’s root + 1, except the lowest zone which likely spans downward to the lowest MIDI note (or maybe to root itself). - They mention the multi-sampler “fills down”, meaning each new higher sample covers its range down to just above the previous sample. The highest sample covers upward to the top of the keyboard presumably. The device might not explicitly store the upper bound of a zone if it assumes fill-down logic; it might only store each zone’s root and sample, and at load time reconstruct the ranges. However, to be safe, it could store the zone range endpoints as well.
For each zone, the stored data will be similar to the one-shot sample: - Sample file reference[119]. - The root key of that zone (for correct pitch). - Start, loop start, loop end, end points[120][121][122]. - Playback direction (forward/backward)[123]. - Pan, loop crossfade (fade), gain[124][125]. - Loop mode (the multi-sampler explicitly has a loop type setting toggle for each zone: loop forever vs loop until key release vs no loop)[102]. That is an extra parameter compared to the drum one. - Possibly an envelope mode for release: but likely just handled by loop until release vs forever.
It appears the multi-sampler shares many editing parameters with the one-shot sampler (the interface looks similar, with additional zone management). The max 24 zones and their base keys need storing. Also, the zones concept doesn’t directly include velocity splits (the manual doesn’t mention velocity layers, so likely one velocity layer per zone – they fill by key only).
When clearing a sample from a multi-sample key, it behaves like the drum (removes assignment, doesn’t delete file)[126]. So again references remain intact.
Summary of sample references: The project file must reference every sample used in: - Any drum kit track (up to 24 samples). - Any one-shot sample track (1 sample). - Any multi-sample track (up to 24 samples). - Additionally, presets: If a user loaded a “sample engine preset” (for example, a drum kit preset from TE), that preset’s samples likely reside in the presets folder. The forum information suggests that user-created presets that use samples will have copies of those samples in the preset’s folder[11]. If the project loaded such a preset, the samples might actually be referenced via the preset folder. However, the project probably doesn’t need to know it came from a preset – it will just have the sample assignments. It does mean those sample file paths might not be under samples/ but under presets/ (e.g., presets/Drum/Kit123/kick.wav). So the file format’s sample references can potentially include paths into the preset directory as well.
Therefore, a reverse engineer should not assume all sample paths start with samples/user; they could be anywhere in the samples or presets area.
One more point: Sample Slot Indices vs Musical Pitches: The project might identify drum keys by musical note (e.g. C3, C#3, etc.) or by index 0–23. The OP–XY likely uses a fixed mapping (for example, maybe the drum sampler spans two octaves from F# to F or something). To properly reconstruct, one might need the exact mapping used. The manual doesn’t specify the note range for drum mode, but given 24 keys, it could be e.g. C2 to B3 (just as an example). Multi-sampler zones definitely are identified by their root note value.
Auxiliary Tracks (9–16) and Effect Settings
Tracks 9–16 on OP–XY are the auxiliary tracks, which serve various special purposes. They are: - Track 9: Brain™ (musical key and scale transposer) - Track 10: Punch-in FX (performance effects track) - Track 11: External MIDI (output to MIDI gear, separate from the instrument tracks’ external engine usage) - Track 12: External CV (CV/Gate output track) - Track 13: External Audio (audio input/output management) - Track 14: Tape (live audio looper/glitcher) - Track 15: FX I (first send effect processor) - Track 16: FX II (second send effect processor)
Each of these has different kinds of data to store. Many of the aux tracks can also have sequencer patterns (the manual says you can create patterns for auxiliary tracks just like instrument tracks[127]). We should consider each briefly:
Brain (Track 9): The Brain is an intelligent music theory track that detects or sets the global key and scale and can transpose other tracks in real-time[128][129]. It doesn’t play a sound by itself, but it influences other tracks. Data to store: - Key and Scale: If Brain is in manual mode (as opposed to auto-detect), the user-chosen key (e.g. C, C#, D, etc.) and scale (major, minor, etc.) are stored[130][131]. If it’s in auto mode, perhaps a flag indicates auto, and the current detected key might not need storing (it could recalc on load). But since auto-detect could come up with a key, they might just store whatever the last known key/scale was anyway. It’s safer to store the key and mode. - Routing of tracks to Brain: In the Brain’s routing module, you can select which instrument tracks (1–8) are fed into the brain for analysis and which tracks get transposed by it[132][133]. The user can toggle each track on/off for Brain influence. So likely an 8-bit mask or 8 boolean flags for tracks 1–8 (and maybe also whether auxiliary tracks are considered, but they said only routed instrument tracks affect detection[134]). The brain track itself is track 9, so it might have an internal data structure storing which tracks are linked. - Brain pattern data: It’s not explicitly stated that Brain has a sequence of its own – it’s more of a live processor. However, one could “riff over your song” by playing the keyboard in the Brain track to transpose live[135][136]. If you recorded that, would it create sequenced transposition changes? Possibly not; likely Brain is not a step sequencer. So track 9 probably doesn’t have pattern data in the same sense. We can assume no note pattern is stored for Brain (or if it is, it’s minimal). The main thing is its state (scale, routing).
Punch-in FX (Track 10): This track hosts the Punch-in effects, which are triggered by playing keys (divided into two groups: low octave affects percussion tracks, high octave affects melodic tracks)[137][138]. When you perform punch-in FX live while recording, those actions are recorded onto the punch-in track as a sequence of triggers[139]. So, yes, Track 10 can have pattern data – essentially which punch-in effect (which key) is triggered at which step. The punch-in track’s pattern timeline would be saved similar to an instrument track pattern (though the “notes” correspond to effect triggers). The file should store any recorded punch-in events for each punch-in pattern (up to 9 patterns for track 10 as well). There aren’t continuous parameters here, just the triggers (and potentially the motion sensor if some effects use gyroscope or pitchbend – but those might modulate the effect in real time rather than be sequenceable).
Other data for Punch-in track: - Possibly which punch-in FX bank or set is loaded – but OP–XY likely has a fixed set of punch-in effects (like beat repeat, stutter, etc.) that are always available, so no alternate “engine” to select. So probably no engine ID, it’s fixed. - No unique per-track parameters beyond the sequence events. So track 10’s data is mostly its pattern sequences (if any).
External MIDI (Track 11): This auxiliary track is distinct from using an instrument track with external engine. Track 11 is dedicated for controlling external MIDI gear and has some enhanced capabilities: - It can sequence notes like any track (so it will have patterns of notes/steps to send out). - It provides up to 8 assignable CC controls (M2 and M3 pages show CC1–CC8 which you can assign and adjust)[140]. If those CC motions can be recorded per step or automated, the file might need to store any CC automation sequence. At the very least, it should store which CC numbers are assigned to the 8 slots (so that the UI knows which CC each encoder controls)[140]. This could be considered part of track settings. Possibly current CC values might not need storing unless they were locked in the sequence. - The MIDI channel for this track (but if track 11 is fixed as “External MIDI track”, TE might have given it a fixed channel or also set via project settings like the others). Since project settings allow setting MIDI channel per track 1–16[85], track 11’s channel is determined there. - No internal sound engine, so no synth params, etc., just sequence data and CC mapping.
So for track 11, ensure the file can represent: its note pattern events (like any other track pattern), and any recorded CC automation or at least the mapping of CC numbers. It might store CC events similarly to parameter locks on a step (if you record a CC knob wiggle, it could become step-locks or maybe a continuous automation lane – uncertain, but likely step-based since OP–XY is step sequencer at heart).
External CV (Track 12): This track outputs CV/Gate on the TRS multi-out (when multi-out is set to CV mode)[141][142]. It sequences analog synths. For file storage: - It will have patterns of notes and gates (like a monophonic sequence). Possibly velocity could map to CV modulation or gate voltage, but the manual doesn’t detail that. Let’s assume it at least outputs pitch CV and a gate for note on/off. - There might be track-specific settings like CV calibration or scale, but TE hasn’t indicated any user calibration. The only thing is multi-out must be set to CV mode (that’s a system setting, not per project – except maybe they allow saving multi-out config per project, but it seems like a global mode). - The track probably doesn’t require storing anything except its sequence (notes). It uses no internal engine. - MIDI channel setting for track 12 exists but isn’t used when in CV mode, though if you repurpose track 12 as a normal instrument in a different context, the channel would matter. Regardless, project settings have a MIDI channel for it.
External Audio (Track 13): This is essentially a routing and effects track for audio input and output. It has quite a few parameters: - Input Source: Selectable between internal mic, headset mic, line input, USB audio, or even the main output (loopback)[143]. The chosen input (mic, line, etc.) is a setting stored in track 13. - Input Drive (Gain): An analog preamp gain for external input (only applies to analog sources)[144]. Stored value 0–31 dB range. - Input Level: Volume of the external audio input mixed into the device’s main mix[145]. - Mix to Main: A “mix” knob that adjusts how much of the external audio track’s routed audio is sent to the main output[146]. This sounds a bit confusing but the manual text suggests track 13 can take audio from instrument tracks and feed it into main – essentially acting as a submix. Likely this is a wet/dry control for how the external audio track blends with normal output. - Activate Input: Possibly a toggle (the UI shows an “activate input” section, likely enabling monitoring)[147], though the snippet is incomplete. It might not need a stored parameter if it’s just the mix knob. - Routing (instrument tracks to aux output): Pressing M2 on ext audio track opens a routing matrix for sending instrument tracks to the aux output (the multi-out jack when configured for audio)[148]. Here you can enable/disable each track 1-8 and set an “amount of audio” going into the external audio track for each[68]. This is crucial: track 13 effectively can tap audio from the instrument tracks and route it out separately. The manual even says you can set levels different from the main mix for each track when sending to the external output[149]. So the file needs to store an 8-channel send level (or at least on/off, but it explicitly says you can set the amount, implying a level per track). We saw earlier under instrument filter page that shift+dark knob was aux send – likely this is the same value as these routing levels[67][68]. So, either track 13 holds an array of 8 send values, or each instrument track stores an “aux send” value. Either way, the project must capture these. It is likely implemented as part of ext audio track data, so that track 13 in the file has the list of tracks and their send levels. - Filter: The ext audio track includes a high-pass/low-pass filter (M3 page) on the external audio bus[150][151]. Two values: HP cutoff and LP cutoff are stored[151]. (Shift functions allow FX send levels from this track to FX I/II, and a tape send, see next bullet.) - Send to FX and Tape: The last lines show “hold shift and rotate mid for tape send, light/white for fx send levels”[152]. That means the external audio track (track 13) can send its output into the Tape track and FX tracks just like an instrument track can. So we have: - Ext Audio -> Tape send level - Ext Audio -> FX1 send level - Ext Audio -> FX2 send levelThese three send amounts need to be stored as part of track 13’s settings. Essentially, track 13 itself has send levels to the effect tracks (similar to how each normal track has sends). - LFO: The ext audio track has an LFO (M4 page) for modulating its parameters[153][154]. So like instrument tracks, track 13 can have an LFO with speed, amount, destination, parameter, type. Likely similar structure: probably to modulate the input level, or filter, or mix, etc. The destinations would be within ext-audio track’s modules (source, drive, level, filter cutoffs maybe). So we must store the LFO settings for track 13 (type, rate, depth, dest, param, and any sub-parameter if, say, random LFO envelope). - Patterns: Does track 13 have a sequencer pattern? Possibly no – it’s more of a continuous input. It doesn’t generate notes. You wouldn’t sequence the incoming audio. So it probably doesn’t use patterns 1–9 at all (or if it does, they would be empty). We can assume track 13 has no note data to store.
Tape (Track 14): The Tape track is a live looper that can capture and rearrange audio from other tracks. It’s somewhat analogous to the OP-1’s tape, but here it’s an effect track. Key parameters: - Pitch: Tape speed pitch effect (dark gray knob)[155]. - Speed: Fine speed control (mid gray knob)[156]. - Loop Length: The length of the tape loop (light gray knob)[157]. Possibly quantized in beat lengths. - Mix: Wet/dry mix of the tape effect vs original audio (white knob)[158]. - Routing: Similar to ext audio, you can route instrument tracks into the tape track via M2 module[159][160]. You toggle tracks 1-8 on/off and adjust how much of each track’s audio feeds the tape[161]. The manual says “you can set the amount of audio coming into the tape from each track, which can be totally different to the main mix”[162]. So again, an array of 8 send levels (Instrument track -> Tape send). This is analogous to the FX sends but for the Tape. The values for these sends likely correspond to some “Tape send” parameter per track (the UI mentions hold shift in the filter page of instrument tracks to control tape send as well, in ext audio snippet it said shift+mid for tape send on track 13; possibly instrument tracks might have similar). - Filter: The tape track has its own HP/LP filter (M3) to shape the taped audio[163][164]. Two parameters: high-pass cutoff (dark) and low-pass cutoff (white)[165][166]. Additionally, “hold shift and rotate light gray and white to control FX send levels” for the tape track[167]. That indicates Tape track (14) can send to FX1 and FX2 as well (like ext audio could). So store tape -> FX1 send and tape -> FX2 send values. - LFO: Tape track has an LFO (M4) for modulating tape parameters[168][169], similar to others. The dest could be tape speed, pitch, etc. We store its type, rate, amount, dest, param, etc.[169][170]. - Pattern/Clips: The Tape track allows you to “use the musical keyboard to play clips from any tracks routed into the tape”[171]. Essentially, you can treat recorded tape buffer slices as playable like an instrument (similar to a DJ tape scratching concept). It’s not entirely clear if the tape track can have a sequence of triggered clips. The interface implies you could record a sequence of tape manipulations (like triggering different tape playback slices on steps). If so, track 14 might have pattern data that records which key (clip) is triggered on which step. The manual doesn’t explicitly confirm recording those, but since it says you can perform and “rearrange audio” with tape, one could imagine sequencing it. For completeness, be open to track 14 having pattern events representing tape slice triggers. If they exist, they’d be saved similarly to notes (the “notes” would correspond to tape clips).
At the very least, track 14’s state includes its effect settings (pitch, speed, length, mix), routing of tracks to tape (send levels 1–8), filter settings, send levels to FX, and LFO. Possibly sequence events if applicable.
FX I and FX II (Tracks 15 & 16): These are send effect processors. They each host one effect algorithm (such as reverb, delay, chorus, etc.) that you can send other tracks into. Key data to store: - Effect Engine Type: You can change the effect loaded in each FX slot by holding shift and pressing the FX button, then selecting from a list[172][173]. The OP–XY has multiple effect engines (the manual references an FX chapter listing them). For example, built-in effects likely include Delay, Reverb, Chorus, Distortion, Lofi, Phaser, etc. So the project file must note which effect is loaded in FX1 and in FX2. - Effect Parameters: Each effect engine will have its own parameters, controlled by the encoders on the FX Engine (M1) page[174]. Typically, an effect might have up to 4 main parameters mapped to the four knobs (similar to synth engines). For instance, a delay might have Time, Feedback, Tone, Mix, etc. The file should save all current parameter values for the effect in slot 1 and slot 2[174]. If an effect has more than 4 settings or multiple pages, those would need storing too (but likely TE kept it to 4 per FX). - FX LFO: Each FX track also has an LFO (M4) for modulating effect parameters[175][176]. So store the LFO settings for track 15 and 16 (type, rate, depth, destination parameter). The “destination” in this context is on the effect itself – e.g., modulate the delay time or reverb decay. The manual lines show the same format: destination module and parameter selection for the FX LFO[177][176] (in FX tracks, there might be fewer module choices since basically only the FX engine module is relevant, but they might also allow modulating that FX’s filter or send to the other FX). - Routing (sends): Tracks send audio to these FX via the FX send levels. Every instrument track and certain aux tracks have two send amounts: one for FX I and one for FX II[178][179]. In the mix mode, you adjust “FX I send” and “FX II send” per track[178][179]. These sends are not stored in the FX track itself but as part of each track’s mix settings. We already noted that scenes probably capture send levels (if they truly capture “mix settings”). If scenes indeed include sends, then the send levels could vary per scene. However, if the manual only meant volume/mute vary and sends are static, the file would store a single send value per track globally. This is a bit ambiguous. Given that pan wasn’t explicitly mentioned either but likely is global, it’s possible that effect sends and pan are global track parameters, not scene-variant. For safety, one should be prepared that either: - Sends (and pan) are saved per scene (so each scene entry has those values for each track), or - Sends/pan are saved once per track in the project (like a default mix), and scenes only override volume/mute.
The wording “scenes remember ... mix settings”【30†L157-L165】 suggests possibly all mix values, which leans toward scene-level control of sends too. If that’s true, then to reconstruct a project entirely, you need to capture send levels for each track in each scene. That’s a lot of data but manageable. If not, then just static sends per track (which is simpler). This detail might be clarified by user experimentation, but from documentation alone, we highlight it as something to account for.For reverse-engineering strategy, check if send levels change when switching scenes in a saved project or if they remain constant. If constant, they’ll be in one place (perhaps near track pan/levels in a default scene or track section). If variable, they’ll appear in scene records.
Inter-FX send: FX I can send into FX II (effect chaining). The manual says “when in FX I, hold shift and rotate white knob to control the send level to FX II from FX I.”[180][181]. That is a parameter of FX1 track: how much of FX1’s output feeds into FX2. The project must store this single value (0–100% send from FX1 to FX2). It’s essentially the feedback routing between the two effect busses. There’s no mention of FX2 sending into FX1, so it’s a one-way chain.
Patterns: Likely, the FX tracks do not have note patterns. You don’t sequence notes on a reverb. The keyboard in FX mode is used to preview the effect with the last played instrument sound[182], not to create a sequence. So tracks 15 and 16 have no step sequences to store (just continuous parameters as above).
Mix Levels and Panning: We’ve covered track sends and volumes with scenes, but to reiterate general mix: - Track Volume: Each track’s audio level (0-100%). Scenes definitely save these[34]. - Track Mute: On/off stored in scenes[34]. Mutes in OP–XY are note mutes, meaning muted tracks won’t trigger new notes (but already playing sounds might ring out)[183]. - Track Pan: Each track’s stereo pan position (L<->R)[184]. This is adjusted in mix mode per track. The manual doesn’t explicitly list pan in scene memory, but it calls mix mode for balancing, implying pan is likely a global mix parameter (but possibly scene-stored under “mix settings” as well). We assume the project stores a pan value for each track (somewhere). - Track Solo: Solo isn’t really stored; it’s a momentary UI function. - Mute Groups: Aside from drum mute groups for samples, if any global grouping, none mentioned aside from the percussion/melodic group mixing (coming next).
Master Group and FX Settings: The Mix (Master) section of project includes: - Percussion Group Level: A grouped volume fader that collectively controls all “percussive engines” (e.g., any track using a drum sampler, presumably)[185]. The device automatically routes those to a percussion bus. The Melodic Group Level similarly controls all melodic tracks (synth engines, one-shots, etc.)[186]. These two values are stored per project so that the relative balance between your drum bus and melodic bus is reproducible[187][186]. - Master EQ: A 3-band master equalizer. In Mix mode M2, you have Low, Mid, High gain knobs and a Blend control[188][189]. The Blend essentially morphs between two EQ profiles (neutral vs the adjusted curve)[190]. The state of the EQ can be represented by 4 values: low gain, mid gain, high gain, blend. These are part of the project’s master section. - Master Saturator: A master tape saturation/compressor effect on M3. It has “Low” (input gain), “Mid” (soft clip amount), “High” (tone tilt), and “Blend” (wet/dry mix) controls[191][192]. Store those four values. - Master Compressor: On the Master (M4) page, there’s a compressor amount (light gray knob)[193]. It likely controls overall compression intensity (could be threshold or mix of a fixed compressor). This is one value. - Master Output Level: Also on Master page, a final level (white knob) that sets how much to boost into the limiter on output[194]. One value (often you keep it at 0 dB, but if adjusted, needs storing). - Output Limiter: The OP–XY likely has a fixed limiter at end (they mention output limiter in passing[195]). There’s no user setting for the limiter aside from the level going into it (which is that master level). - Metronome Volume: The metronome volume and on/off might be stored globally. The tempo screen’s white knob sets metronome level and click to toggle it[196]. While not musically critical to the content, it is a setting that might persist per project (or it could be a system setting, unclear). The manual doesn’t specify if metronome settings are per project or system; likely system, but if not, include it. - Tempo and Swing: The project’s Tempo (BPM) is of course stored[197]. If the user tapped or set a specific BPM, that number is saved with the project. Groove (Swing/Shuffle) settings are also saved. OP–XY has a concept of Groove Type and Groove Amount[198][199]. The groove type is like a template (shuffle, half-shuffle, “bombora”, etc.)[200][201] and the amount dial blends between adding swing vs shuffle (negative vs positive around center)[199]. So we have: - BPM value (could be integer or with decimal). - Groove type (probably an index 0–... corresponding to the named grooves[202][203]). - Groove amount (a signed value or two values for swing vs shuffle, but manual implies one knob: counter-clockwise = shuffle, clockwise = swing[199]; possibly stored as a single offset value where 0 = no swing, positive = swing, negative = shuffle). - Time Signature: In project settings you can set time signature to 3/4, 4/4, 5/4, 6/8, 7/8, or 12/8[204]. That should be stored (likely numerator and denominator or an enum for those common signatures). Time signature mainly affects the grid and how the bar/sequence length is interpreted.
MIDI Mapping and Controllers: Finally, the project includes MIDI configuration: - Track MIDI Channels: As mentioned, each track (1–16) has an assignable MIDI channel for output and input[85]. This is crucial if you’re sequencing external gear or controlling OP–XY from an external keyboard. The project settings MIDI page stores 16 values (one per track, channels 1–16 or off). Likely 0 means off or no channel, or they allow “OMNI” or something, but probably each track has 1–16 or maybe 0=Omni. The user manual specifically says you can set the MIDI channel on each track for connecting external devices[85]. - Clock/Sync settings: Not explicitly in manual, but OP–XY can send/receive MIDI clock, etc. Possibly not stored per project but rather a system setting. - CC Mappings: If any custom MIDI CC mappings were done (like track 11’s CC knobs assignments), those should be included as part of that track’s data (as discussed in ext MIDI). - CV Calibration: Not mentioned, likely fixed hardware calibration. - Tape tempo sync: The random LFO had an option to tempo sync by turning rate knob fully anti-clockwise until an icon shows[74]. That suggests the LFO rate can be synced, which might quantize to BPM. But that’s an internal detail (just a flag in LFO settings per track if chosen). - Other control mappings: The OP–XY also has a MIDI controller mode (to use it as a controller for a DAW)[205], but that’s outside project scope (not something saved in a project file).
Conclusion and Reverse-Engineering Approach
In summary, the OP–XY project file encodes a hierarchy of musical data: - Global project settings and metadata: tempo, time signature[204][197], groove type/amount[204][199], transpose (global key shift)[206], voice allocation per track[14], MIDI channel per track[85], and possibly a project name. Also master mix settings (group levels[187], EQ[188], saturator[207], master comp/level[193][194]). - Track configurations (for each of 16 tracks): Engine type (or aux track function), instrument parameters (synth or sampler settings as detailed), track-specific mixer settings (pan, FX sends; or these might be solely in scenes), track-level LFO settings (for tracks that have LFOs – instrument and aux tracks 13,14,15,16 all do)[208][154], and any unique track toggles (play mode for synth tracks[57], etc.). Track 13 and 14 store their routing matrices for tape/aux sends[68][160]. Tracks that don’t make sound (e.g. ext MIDI, ext CV) still have a “track” entry for their sequence and channel. - Pattern data: For each track, up to 9 patterns, each containing the sequence of steps (notes and step components, parameter locks)[209][28]. Patterns on instrument tracks also include the instrument sound data if patterns carry their own presets (and possibly a flag if sound-linked). - Scenes: Up to 99 scenes, each essentially a table of 16 track pattern numbers + 16 track volume/mute (+ possibly pan/sends)[33]. Scenes provide the arrangement snapshots. - Songs: Up to 14 songs, each a sequence (list) of scene numbers (max 96 steps) and a loop flag[43][40].
All these elements must be accounted for when reverse-engineering the .xy file format. The file is likely binary and not self-describing, so mapping out offsets for each section (perhaps with a header containing counts for scenes, etc.) will be needed. Clues can be gathered by observing how file size changes with added patterns or scenes, and by correlating known values (like a specific tempo or a distinct sample filename in a project) with the binary data. The manual provides the blueprint of what must be in the file: every musical and control detail described above has to live somewhere in the project data in order for the OP–XY to restore the state exactly “as you left it”[210].
By using the manual’s specifications – e.g., knowing there are 16 tracks, 9 patterns each, 99 scenes, etc. – one can infer structure in the file. For example, 99 scenes × 16 tracks = 1584 pattern references; you might search the binary for a block of 1584 bytes (if one byte per pattern ref) or 1584 16-bit words (if two bytes per ref including volume, etc.). Similarly, sample names might be stored as plain text within, helping locate those sections.
In conclusion, to successfully reverse engineer the format, ensure your parser design covers: - Instrument data (including complex nested structures for sampler engines, and multiple modulators like envelopes and LFOs), - Sequencer events (with multi-note steps and numerous modifiers), - Arrangement (scenes/songs linking it all), - Mix and effect settings (for both track-level and master-level audio processing), - and External references (like sample file paths and MIDI mappings).
All of these are confirmed or strongly implied by Teenage Engineering’s official documentation, as we have cited above. With this information, one can methodically decode the binary project file by matching these expected data points to patterns in the file, ultimately enabling custom project editing or generation outside the OP–XY.
References:
Teenage Engineering OP–XY User Guide and How-To Articles[209][33][41][211][12][29][28][30][14][48][55][212][78][92][213][8][116][118][68][214][215][172][177][178][216][183][185][193][194][197][199][204][85].
[1] OP-XY project file (.xy) reverse engineering efforts? - OP-XY - OP Forums
https://op-forums.com/t/op-xy-project-file-xy-reverse-engineering-efforts/29850
[2] [210] OP–XY guide: hardware overview
https://teenage.engineering/guides/op-xy/hardware-overview
[3] [4] [5] [6] [7] [50] [51] [86] [87] [88] [93] [94] [140] [141] OP–XY guide: how to
https://teenage.engineering/guides/op-xy/how-to
[8] [90] [91] [92] [95] [96] [97] [98] [99] [100] [101] [102] [103] [104] [105] [106] [107] [108] [109] [110] [111] [112] [113] [114] [115] [116] [117] [118] [119] [120] [121] [122] [123] [124] [125] [126] [213] OP–XY guide: sample
https://teenage.engineering/guides/op-xy/sample
[9] [10] [11] [52] OP XY storage and file structure - OP-XY - OP Forums
https://op-forums.com/t/op-xy-storage-and-file-structure/28915
[12] [30] [31] [32] [37] [38] [39] [40] [41] [42] [43] [44] [45] [46] [127] [211] OP–XY guide: arrange
https://teenage.engineering/guides/op-xy/arrange
[13] [33] [34] [209] guide OP–XY
https://teenage.engineering/guides/op-xy/workflow
[14] [85] [89] [204] [206] OP–XY guide: project
https://teenage.engineering/guides/op-xy/project
[15] [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] guide OP–XY
https://teenage.engineering/guides/op-xy/step-components
[35] [36] [178] [179] [183] [184] [185] [186] [187] [188] [189] [190] [191] [192] [193] [194] [195] [207] [216] OP–XY guide: mix
https://teenage.engineering/guides/op-xy/mix
[47] [49] [53] [54] [55] [56] [57] [58] [59] [60] [61] [62] [63] [64] [65] [66] [67] [69] [70] [71] [72] [73] [74] [75] [76] [77] [78] [79] [80] [81] [82] [83] [208] [212] OP–XY guide: instrument
https://teenage.engineering/guides/op-xy/instrument
[48] [84] [205] OP–XY
https://teenage.engineering/guides/op-xy?srsltid=AfmBOoqwK7S-LlJFEc5Ptg_bDCTBcrDTJBSAr8xHUur6eFlGqQIh4ak-
[68] [128] [129] [130] [131] [132] [133] [134] [135] [136] [137] [138] [139] [142] [143] [144] [145] [146] [147] [148] [149] [150] [151] [152] [153] [154] [155] [156] [157] [158] [159] [160] [161] [162] [163] [164] [165] [166] [167] [168] [169] [170] [171] [172] [173] [174] [175] [176] [177] [180] [181] [182] [214] [215] OP–XY guide: auxiliary
https://teenage.engineering/guides/op-xy/auxiliary
[196] [197] [198] [199] [200] [201] [202] [203] guide OP–XY
https://teenage.engineering/guides/op-xy/tempo